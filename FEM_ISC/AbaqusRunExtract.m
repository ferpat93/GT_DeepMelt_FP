function [indexes]=AbaqusRunExtract(RootINP_fullpath,NameCase,FolderName,parameters,index)

%% RUN ABAQUS - FROM INP 
      
disp('Simulation Started') 
tic
% Run the input file with Abaqus
system(['abaqus job=' NameCase]);

sw=true; 
tic; 
while sw 
    % Pause Matlab execution in order for the lck file to be created 
    pause(0.5); 
    % While the lck file exists, pause Matlab execution. If it is 
    % deleted, exit the while loop and proceed. 
    while exist([NameCase '.lck'],'file')==2 
        pause(0.1) 
        % the lck file has been created and Matlab halts in this loop. 
        % Set sw to false to break the outer while loop and continue 
        % the code execution. 
        sw=false; 
    end 
    % In case that the lck file cannot be detected, then terminate 
    % infinite execution of the outer while loop after a certain 
    % execution time limit (5 sec) 
    if sw && (toc>5) 
        sw=false; 
    end 
end  
disp('Simulation Finished') 
toc

%% RETRIEVE CONTOUR MAP

%Modify .py

% Run the Python file from the shell
Python_fullpath='C:\Users\lfp3\Dropbox\GT\Spring-18\IS_Paper\Matlab\Export_FO.py';
PythonLine=28;
%copyfile(Python_fullpath,pwd)
% Start modifying text
fin = fopen(Python_fullpath,'r');
fout = fopen('Export.py','w');

idk=0;
while ~feof(fin)    
    idk=idk+1;
    s = fgetl(fin); 
    if idk==PythonLine
        s=strcat("name='",NameCase,".odb'");
    end
    fprintf(fout,'%s\n',s); 
end

fclose(fin);
fclose(fout);

system('abaqus cae noGUI=Export.py');

%% Fit Ellipse and return geometric Indexes
indexes=EllipseAxis();


%% To Do - Write to master excel file
Data(i,:) = [Parameters_i Indexes_i];
        
        cd(RootFolder) 
        
end

%% Auxiliar functions to import data
function [Index]=EllipseAxis()
%Imports data, fits to ellipse and returns axis

%% Initial Variables
r0=1;
angInt=deg2rad(90/15);
zeroPE=1e-3;
EP_filename='ExportPEMAG.txt';
Cav_filename='ExportCavity.txt';


%% Import .txt files

EP=importEP(EP_filename);
Cavity=importCav(Cav_filename);
ThresholdEP=[0 zeroPE;10 zeroPE];
Ellipse_points=zeros(16,2);
Cavity_points=zeros(16,2);

for ray=0:15
    ang=ray*angInt;
    
    %Cavity
    Cavity_points(ray+1,:)=[Cavity(ray+1,1)*cos(ang) (Cavity(ray+1,2)+r0*sin(ang))];
    
    %EP
    [EP_Limit,~] = polyxpoly(EP(:,1),EP(:,2+ray),ThresholdEP(:,1),ThresholdEP(:,2));
    Ellipse_points(ray+1,:)=[(EP_Limit(1)+r0)*cos(ang) (EP_Limit(1)+r0)*sin(ang)];
end

% Fit Cavity Ellipse and get axis
ellipse_struct=fit_ellipse(Cavity_points(:,1),Cavity_points(:,2)); % Struct containing ellipse parameters
assignin('base','CavityPoints',Cavity_points)
assignin('base','Cavity_struct',ellipse_struct)

C_Major_axis=ellipse_struct.long_radius
C_Minor_axis=ellipse_struct.short_radius

%Fit EP Boundary Ellipse and get axis
ellipse_struct=fit_ellipse(Ellipse_points(:,1),Ellipse_points(:,2)); % Struct containing ellipse parameters

assignin('base','Ellipse_points',Ellipse_points)
assignin('base','EP_struct',ellipse_struct)

EP_Major_axis=ellipse_struct.long_radius
EP_Minor_axis=ellipse_struct.short_radius

%Find Indexes

%Cavity
Index(1,1)=100*(((C_Major_axis*C_Minor_axis)/(r0^2))-1);
Index(1,2)=C_Minor_axis/C_Major_axis;

%EP Boundary
Index(1,3)=1*(((EP_Minor_axis*EP_Major_axis)-(C_Major_axis*C_Minor_axis))/r0^2);
Index(1,4)=EP_Minor_axis/EP_Major_axis;

end
function ExportCavity = importCav(filename, startRow, endRow)
%IMPORTFILE Import numeric data from a text file as a matrix.
%   EXPORTCAVITY = IMPORTFILE(FILENAME) Reads data from text file FILENAME
%   for the default selection.
%
%   EXPORTCAVITY = IMPORTFILE(FILENAME, STARTROW, ENDROW) Reads data from
%   rows STARTROW through ENDROW of text file FILENAME.
%
% Example:
%   ExportCavity = importfile('ExportCavity.txt', 2, 53);
%
%    See also TEXTSCAN.

% Auto-generated by MATLAB on 2018/04/26 21:37:56

%% Initialize variables.
delimiter = ' ';
if nargin<=2
    startRow = 2;
    endRow = 102;
end

%% Format for each line of text:
%   column1: double (%f)
%	column2: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
textscan(fileID, '%[^\n\r]', startRow(1)-1, 'WhiteSpace', '', 'ReturnOnError', false);
dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'TextType', 'string', 'ReturnOnError', false, 'EndOfLine', '\r\n');
for block=2:length(startRow)
    frewind(fileID);
    textscan(fileID, '%[^\n\r]', startRow(block)-1, 'WhiteSpace', '', 'ReturnOnError', false);
    dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'TextType', 'string', 'ReturnOnError', false, 'EndOfLine', '\r\n');
    for col=1:length(dataArray)
        dataArray{col} = [dataArray{col};dataArrayBlock{col}];
    end
end

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Create output variable
ExportCavity = [dataArray{1:end-1}];
end
function ExportPEMAG = importEP(filename, startRow, endRow)
%IMPORTFILE Import numeric data from a text file as a matrix.
%   EXPORTPEMAG = IMPORTFILE(FILENAME) Reads data from text file FILENAME
%   for the default selection.
%
%   EXPORTPEMAG = IMPORTFILE(FILENAME, STARTROW, ENDROW) Reads data from
%   rows STARTROW through ENDROW of text file FILENAME.
%
% Example:
%   ExportPEMAG = importfile('ExportPEMAG.txt', 2, 803);
%
%    See also TEXTSCAN.

% Auto-generated by MATLAB on 2018/04/26 21:36:55

%% Initialize variables.
delimiter = ' ';
if nargin<=2
    startRow = 2;
    endRow = 1602;
end

%% Format for each line of text:
%   column1: double (%f)
%	column2: double (%f)
%   column3: double (%f)
%	column4: double (%f)
%   column5: double (%f)
%	column6: double (%f)
%   column7: double (%f)
%	column8: double (%f)
%   column9: double (%f)
%	column10: double (%f)
%   column11: double (%f)
%	column12: double (%f)
%   column13: double (%f)
%	column14: double (%f)
%   column15: double (%f)
%	column16: double (%f)
%   column17: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
textscan(fileID, '%[^\n\r]', startRow(1)-1, 'WhiteSpace', '', 'ReturnOnError', false);
dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'TextType', 'string', 'ReturnOnError', false, 'EndOfLine', '\r\n');
for block=2:length(startRow)
    frewind(fileID);
    textscan(fileID, '%[^\n\r]', startRow(block)-1, 'WhiteSpace', '', 'ReturnOnError', false);
    dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'TextType', 'string', 'ReturnOnError', false, 'EndOfLine', '\r\n');
    for col=1:length(dataArray)
        dataArray{col} = [dataArray{col};dataArrayBlock{col}];
    end
end

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Create output variable
ExportPEMAG = [dataArray{1:end-1}];
end
function ellipse_t = fit_ellipse( x,y,axis_handle )
%
% fit_ellipse - finds the best fit to an ellipse for the given set of points.
%
% Format:   ellipse_t = fit_ellipse( x,y,axis_handle )
%
% Input:    x,y         - a set of points in 2 column vectors. AT LEAST 5 points are needed !
%           axis_handle - optional. a handle to an axis, at which the estimated ellipse 
%                         will be drawn along with it's axes
%
% Output:   ellipse_t - structure that defines the best fit to an ellipse
%                       a           - sub axis (radius) of the X axis of the non-tilt ellipse
%                       b           - sub axis (radius) of the Y axis of the non-tilt ellipse
%                       phi         - orientation in radians of the ellipse (tilt)
%                       X0          - center at the X axis of the non-tilt ellipse
%                       Y0          - center at the Y axis of the non-tilt ellipse
%                       X0_in       - center at the X axis of the tilted ellipse
%                       Y0_in       - center at the Y axis of the tilted ellipse
%                       long_axis   - size of the long axis of the ellipse
%                       short_axis  - size of the short axis of the ellipse
%                       status      - status of detection of an ellipse
%
% Note:     if an ellipse was not detected (but a parabola or hyperbola), then
%           an empty structure is returned

% =====================================================================================
%                  Ellipse Fit using Least Squares criterion
% =====================================================================================
% We will try to fit the best ellipse to the given measurements. the mathematical
% representation of use will be the CONIC Equation of the Ellipse which is:
% 
%    Ellipse = a*x^2 + b*x*y + c*y^2  + f = 0
%  JH we don't need d or e if the center is zero 
% The fit-estimation method of use is the Least Squares method (without any weights)
% The estimator is extracted from the following equations:
%
%    g(x,y;A) := a*x^2 + b*x*y + c*y^2  = f
%JH we don't need d or e if the center is zero 
%    where:
%       A   - is the vector of parameters to be estimated (a,b,c,d,e)
%       x,y - is a single measurement
%
% We will define the cost function to be:
%
%   Cost(A) := (g_c(x_c,y_c;A)-f_c)'*(g_c(x_c,y_c;A)-f_c)
%            = (X*A+f_c)'*(X*A+f_c) 
%            = A'*X'*X*A + 2*f_c'*X*A + N*f^2
%
%   where:
%       g_c(x_c,y_c;A) - vector function of ALL the measurements
%                        each element of g_c() is g(x,y;A)
%       X              - a matrix of the form: [x_c.^2, x_c.*y_c, y_c.^2, x_c, y_c ]
%       f_c            - is actually defined as ones(length(f),1)*f
%
% Derivation of the Cost function with respect to the vector of parameters "A" yields:
%
%   A'*X'*X = -f_c'*X = -f*ones(1,length(f_c))*X = -f*sum(X)
%
% Which yields the estimator:
%
%       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%       |  A_least_squares = -f*sum(X)/(X'*X) ->(normalize by -f) = sum(X)/(X'*X)  |
%       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%
% (We will normalize the variables by (-f) since "f" is unknown and can be accounted for later on)
%  
% NOW, all that is left to do is to extract the parameters from the Conic Equation.
% We will deal the vector A into the variables: (A,B,C,D,E) and assume F = -1;
%
%    Recall the conic representation of an ellipse:
% 
%       A*x^2 + B*x*y + C*y^2 + D*x + E*y + F = 0
% 
% We will check if the ellipse has a tilt (=orientation). The orientation is present
% if the coefficient of the term "x*y" is not zero. If so, we first need to remove the
% tilt of the ellipse.
%
% If the parameter "B" is not equal to zero, then we have an orientation (tilt) to the ellipse.
% we will remove the tilt of the ellipse so as to remain with a conic representation of an 
% ellipse without a tilt, for which the math is more simple:
%
% Non tilt conic rep.:  A`*x^2 + C`*y^2 + D`*x + E`*y + F` = 0
%
% We will remove the orientation using the following substitution:
%   
%   Replace x with cx+sy and y with -sx+cy such that the conic representation is:
%   
%   A(cx+sy)^2 + B(cx+sy)(-sx+cy) + C(-sx+cy)^2 + D(cx+sy) + E(-sx+cy) + F = 0
%
%   where:      c = cos(phi)    ,   s = sin(phi)
%
%   and simplify...
%
%       x^2(A*c^2 - Bcs + Cs^2) + xy(2A*cs +(c^2-s^2)B -2Ccs) + ...
%           y^2(As^2 + Bcs + Cc^2) + x(Dc-Es) + y(Ds+Ec) + F = 0
%
%   The orientation is easily found by the condition of (B_new=0) which results in:
% 
%   2A*cs +(c^2-s^2)B -2Ccs = 0  ==> phi = 1/2 * atan( b/(c-a) )
%   
%   Now the constants   c=cos(phi)  and  s=sin(phi)  can be found, and from them
%   all the other constants A`,C`,D`,E` can be found.
%
%   A` = A*c^2 - B*c*s + C*s^2                  D` = D*c-E*s
%   B` = 2*A*c*s +(c^2-s^2)*B -2*C*c*s = 0      E` = D*s+E*c 
%   C` = A*s^2 + B*c*s + C*c^2
%
% Next, we want the representation of the non-tilted ellipse to be as:
%
%       Ellipse = ( (X-X0)/a )^2 + ( (Y-Y0)/b )^2 = 1
%
%       where:  (X0,Y0) is the center of the ellipse
%               a,b     are the ellipse "radiuses" (or sub-axis)
%
% Using a square completion method we will define:
%       
%       F`` = -F` + (D`^2)/(4*A`) + (E`^2)/(4*C`)
%
%       Such that:    a`*(X-X0)^2 = A`(X^2 + X*D`/A` + (D`/(2*A`))^2 )
%                     c`*(Y-Y0)^2 = C`(Y^2 + Y*E`/C` + (E`/(2*C`))^2 )
%
%       which yields the transformations:
%       
%           X0  =   -D`/(2*A`)
%           Y0  =   -E`/(2*C`)
%           a   =   sqrt( abs( F``/A` ) )
%           b   =   sqrt( abs( F``/C` ) )
%
% And finally we can define the remaining parameters:
%
%   long_axis   = 2 * max( a,b )
%   short_axis  = 2 * min( a,b )
%   Orientation = phi
%
%

% initialize
orientation_tolerance = 1e-3;

% empty warning stack
warning( '' );

% prepare vectors, must be column vectors
x = x(:);
y = y(:);

% % remove bias of the ellipse - to make matrix inversion more accurate. (will be added later on).
% mean_x = mean(x);
% mean_y = mean(y);
% x = x-mean_x;
% y = y-mean_y;
%JH don't need this

% the estimation for the conic equation of the ellipse
X = [x.^2, x.*y, y.^2];
%JH don't need last two terms
a = sum(X)/(X'*X);

% check for warnings
if ~isempty( lastwarn )
    disp( 'stopped because of a warning regarding matrix inversion' );
    ellipse_t = [];
    return
end

% extract parameters from the conic equation
%[a,b,c,d,e] = deal( a(1),a(2),a(3),a(4),a(5) );
[a,b,c] = deal( a(1),a(2),a(3));
%JH we don't need the last two parameters
% Add Rob Barton code to get the true angle of rotation of the long axis
% form the quadratic matrix
Q = [a b/2; b/2 c]; 
% perform eigen Decomp on it
[eigVec, eigValue] = eig(Q);

% compute the angle to the long axis
angleToX = atand(abs(eigVec(2,1))/abs(eigVec(1,1)));

% check sign to get angles from 90-180
% since vector could point other way have to check all 4 quadrants
if ( sign(eigVec(1,1)) == -1 )
% long axis points to the left
if (sign(eigVec(2,1)) == 1 )
% points up so leave in first 0-90 quadrant
angleFromX = angleToX;
else
% Points down, so will treat it as an ellipse with the long
% axis in the 90-180 range since axis can point either way.
angleFromX = 90+(90-angleToX);
end
else
% long axis points to the right
if ( sign(eigVec(2,1)) == 1 )
% long axis point up
angleFromX = 90+(90-angleToX);
else
% long axis points down
angleFromX = angleToX;
end
end
%end Rob Barton code
% remove the orientation from the ellipse
%first check if it's tilted
if ( min(abs(b/a),abs(b/c)) > orientation_tolerance )
    %then extract the tilt
    orientation_rad = 1/2 * atan( b/(c-a) );
    cos_phi = cos( orientation_rad );
    sin_phi = sin( orientation_rad );
%calculate the revised values for a, b,c on the ellipse rotated to zero
    [a,b,c] = deal(...
        a*cos_phi^2 - b*cos_phi*sin_phi + c*sin_phi^2,...
        0,...
        a*sin_phi^2 + b*cos_phi*sin_phi + c*cos_phi^2);
%     [mean_x,mean_y] = deal( ...
%         cos_phi*mean_x - sin_phi*mean_y,...
%         sin_phi*mean_x + cos_phi*mean_y );
%JH-not needed if ellipse centered at zero
else
    orientation_rad = 0;
    cos_phi = cos( orientation_rad );
    sin_phi = sin( orientation_rad );
end

% check if conic equation represents an ellipse
test = a*c;
switch (1)
case (test>0),  status = '';
case (test==0), status = 'Parabola found';  warning( 'fit_ellipse: Did not locate an ellipse' );
case (test<0),  status = 'Hyperbola found'; warning( 'fit_ellipse: Did not locate an ellipse' );
end

% if we found an ellipse return it's data
if (test>0)
    
    % make sure coefficients are positive as required
    if (a<0), [a,c] = deal( -a,-c ); end
    
    % final ellipse parameters
    F           = 1 ;
    [a,b]       = deal( sqrt( F/a ),sqrt( F/c ) );  
    long_radius   = max(a,b);
    short_radius  = min(a,b);

    % rotate the axes backwards to find the center point of the original TILTED ellipse
    R           = [ cos_phi sin_phi; -sin_phi cos_phi ];
%manually define center = 0
X0=0;
Y0=0;
    P_in        = R * [X0;Y0];
    X0_in       = P_in(1);
    Y0_in       = P_in(2);
    
    % pack ellipse into a structure
    ellipse_t = struct( ...
        'long_radius',long_radius,...
        'short_radius',short_radius,...
        'angleToX', angleToX, ...
        'angleFromX', angleFromX, ...
        'status','' );
%Rob Barton code two lines starting w angle
else
    % report an empty structure
    ellipse_t = struct( ...
         'long_radius',[],...
        'short_radius',[],...
        'status',status );
end

% check if we need to plot an ellipse with it's axes.
if (nargin>2) & ~isempty( axis_handle ) & (test>0)
    
    % rotation matrix to rotate the axes with respect to an angle phi
    R = [ cos_phi sin_phi; -sin_phi cos_phi ];
    
    % the axes
    ver_line        = [ [X0 X0]; Y0+b*[-1 1] ];
    horz_line       = [ X0+a*[-1 1]; [Y0 Y0] ];
    new_ver_line    = R*ver_line;
    new_horz_line   = R*horz_line;
    
    % the ellipse
    theta_r         = linspace(0,2*pi);
    ellipse_x_r     = X0 + a*cos( theta_r );
    ellipse_y_r     = Y0 + b*sin( theta_r );
    rotated_ellipse = R * [ellipse_x_r;ellipse_y_r];
    
    % draw
    hold_state = get( axis_handle,'NextPlot' );
    set( axis_handle,'NextPlot','add' );
    plot( new_ver_line(1,:),new_ver_line(2,:),'r' );
    plot( new_horz_line(1,:),new_horz_line(2,:),'r' );
    plot( rotated_ellipse(1,:),rotated_ellipse(2,:),'r' );
    set( axis_handle,'NextPlot',hold_state );

end

end